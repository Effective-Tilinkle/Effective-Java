# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

#### 1. 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
- API 설명, 어떤 순서로 호출하는지, 호출 결과가 이어지는 처리에 어떤 영향을 주는지 까지
- 재정의 가능 메서드 : public과 protected 메서드 중 final이 아닌 모든 메서드
- 재정의 가능 메서드를 호출할 수 있는 모든 상황은 문서로 남겨야 한다.
  - ex) 백그라운드 스레드나, 정적 초기화 과정에서 호출이 일어날 수 있다

#### 2. 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
#### 3. 상속용 클래스를 시험하는 방법은 직접 하위 클래슬르 만들어보는 것이 '유일'하다.
#### 4. 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야한다.
#### 5. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
#### 6. clone과 readOjbect 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

### 상속을 금지하는 법
- 클래스를 final로 선언
- 생성자를 private, default로 선언, public 정적 팩터리를 만들어주는 방법 
- 위 조언은 논란의 여지가 있음
  - 그동안 수많은 프로그래머들은 일반적인 구체 클래스를 상속해 기능들을 추가해왔음
  - 핵심 기능을 정의한 인터페이스가 있고, 클래스가 그 인터페이스를 구현 했다면, 상속을 금지해도 개발하는데 아무런 어려움이 없음
  - 래퍼 클래스 패턴 역시 기능을 증강할 때 상속보다 더 나은 대안임
  
- 구체 클래스(concrete class)가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해짐
  - 이런 클래스라도 상속을 꼭 허용해야겠다면, 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고, 이 사실을 문서로 남기는 것이다.
    - 재정의 가능 메서드를 호출하는 **자기사용 코드를 완벽히 제거하라는 뜻**
    - 이렇게 하면, 상속해도 그리 위험하지 않은 클래스를 만들 수 있다. 메서드를 재정의해도 다른 메서드의 동작에 아무런 영향을 주지 않기 때문

### 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 기계적인 방법
- 각각 재정의 가능 메서드는 자신의 본문 코드를 private '도우미 메서드'로 옮기고, 이 도우미 메서드를 호출하도록 수정한다.
- 그런 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정