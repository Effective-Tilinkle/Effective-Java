# 다 쓴 객체 참조를 해제하라

## 요약
1. 객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체뿐 아니라 그 객체가 참조하는 모든 객체를 회수해 가지 못한다.
   1. 강제로 null 할당하여 해제
   2. null 처리는 바람직한 방법은 아니다. 예외적인 경우만 사용할 것
2. 스택은 자기 메모리를 직접 관리한다
   1. element 배열로 저장소 풀을 만들어 원소들을 관리
   2. 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야한다.
3. **_캐시 역시 메모리 누수를 일으키는 주범_**
   1. WeakHashMap 사용해 캐시를 만들면, 다 쓴 엔트리는 그 즉시 자동으로 제거된다.
   2. 캐시를 만들 때 보통은 캐시 엔트리의 유효기간을 정확히 정의하기 어렵기 때문에, 시간이 지날수록 엔트리의 가치를 떨어트리는 방식을 흔히 사용한다
   3. 이런 방식에는 쓰지 않는 엔트리를 이따금 청소해줘야 한다.
      1. ScheduledThreadPoolExecutor 같은 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하는 방법
      2. LinkedHashMap은 removeEldestEntry 메서드로 후자 방식으로 처리
      3. 더 복잡한 캐시를 만들고 싶다면 java.lang.ref 패키지를 직접 활용
4. 리스너 혹은 콜백도 메모리 누수의 주범
   1. 클라이언트가 등록만하고 명확히 해지하지 않기 때문

## Question
1. 자기 메모리를 직접 관리하는 클래스는 다른건 뭐가 더 있을까?
   1. ChatGPT로 확인해봤으나, null로 메모리 초기화 하는건 잘 안나오고, 바이터 버퍼가 나왔다. 그런데, 실제로 힙메모리관련 파라메터나, clear등으로 메모리에서 할당 정보를 해제 하는데, null로 초기화 하는 내용과는 조금 달라 보인다.
2. WeakHashMap은 다른 곳에서 쓰이는 곳이 더 있을까?
   1. org.apache.commons.httpclient.MultiThreadedHttpConnectionManager의 커넥션 관리용
   2. 자바 코어 api의 클래스로더
   3. 캐시
   4. aspectjweaver 코어에도 있다
   5. 하이버네이트
   6. 제법 자주 쓰이는 듯 보인다
   7. ehcache에선 SoftReference를 사용하는데, 이 녀석은 메모리 부족하지 않으면, GC는 안하는 모양이다
3. 자주쓰는 EhCache는 구현체에서 무엇을 썼을까? (이 녀석은 시간을 지정할 수 있는데...)
   1. 위 내용에 언급했듯이, SoftReference를 사용한다. 
      1. 보통 이 자료구조가 캐시에 많이 쓰인다고 함
4. WeakHashMap과 HashMap 동작의 차이를 보고싶다
   1. 코드로 구현해보았으나, 적절히 동작하지 않음