# clone 재정의는 주의해서 진행하라
1. Cloneable은 복제해도 되는 클래스임을 명시하는 믹스인 인터페이스
  - 마커인터페이스, JVM에게 복제가 가능하다고 알려줌
  - 기본적으로 protected며, 외부에서 접근하려면, public으로 재정의필요
    - reflection으로 가능하지만, 100% 성공 보장이 없음. (해당 객체가 접근이 허용된 clone 메서드를 제공한다는 보장이 없기 때문)
    
2. 실무에서 Clonealbe을 구현한 클래스는 clone메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.
  - 이 기대를 만족시키려면, 그 클래스와 모든 상위 클래스는 복잡하고, 강제할 수 없고, 허술하게 기술된 프로토콜을 지켜야 하는데, 그 결과로 깨지기 쉽고 모순적인 메커니즘이 탄생한다.
  - 생성자를 호출하지 않고도, 객체를 생성할 수 있게됨

3. p78의 오브젝트 명세
   - 강제성이 없다는 점만 빼면, 생성자 연쇄와 살짝 비슷한 메커니즘
   - super.clone을 그대로 호출하게 두면, 의도한대로 동작하지 않는다는 내용
   - ex) A, B, C가 순차로 상속하며, A는 clone 재정의, 나머지는 super.clone을 재정의하지 않고 둔 상태로, C.clone을 하면, 결국 A클래스가 나옴
   - final 클래스면, 하위클래스가 없으니 관례는 무시해도 상관 없음
   - final 클래스의 clone메서드가 super.clone을 호출하지 않는다면, Cloneable 구현필요 X
     - Object의 clone 구현의 동작방식에 기댈 필요가 없기 때문
   - clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치치 않는 동시에 복제된 객체의 불변식을 보장해야한다.
     - p80, 81 예제코드
     - 배열의 clone은 런타임 타입과 컴파일 타임 타입 모두가 원본 배열과 똑같은 배열을 반환한다. 따라서 배열 복제시에 clone메서드 권장됨

4. Cloneable 아키텍처는 '가변객체를 참조하는 필드는 final로 선언하라'는 용법과 충돌한다. 때문에, 복제를 위해, 일부 final 한정자를 제거해야할 수 있다.
   - final로 선언하면, 클론한 가변객체를 할당할 수 없기 때문

5. 연결리스트인 형식의 경우 deepcopy 사용 시, 재귀호출을 하면, 스택오버플로우가 발생할 수 있으니, 반복문으로 복사하는 것을 추천한다.

6. 생성자에서는 재정의될 수 있는 메서드를 호출하지 않아야 하는데, clone도 마찬가지다.
  - 만약 호출하게 되면, 하위 클래스는 복제 과정에서 자신의 상태를 교정할 기회를 잃기 때문이다.

7. Object.clone 메서드는 CloneNotSupprotException을 던진다고 선언했지만, 재정의한 public clone 메서드에서는 throws절을 없애야 한다.
8. 상속용 클래스는 Cloneable을 구현해서는 안된다.

9. Cloneable을 구현한 Thread safe 클래스를 작성할 때는 clone메서드 역시 적절히 동기화해줘야 한다.

10. Cloneable을 구현하는 모든 클래스는 clone을 재정의해야 한다.
    - 기본적으로 불변객체는 아무 필드도 수정할 필요가 없지만, 일련번호나 고유 ID는 비록 기본타입이나 불변일지라도 수정을 꼭해줘야 한다.
    - **Cloneable을 굳이 안쓰더라도, 변환(복사) 생성자 혹은 변환(복사) 팩터리로 대체 가능하하며, Cloneable보다 더 낫다.** (배열 예외)

## 요약
- Cloneable이 몰고 온 모든 문제로 보아, 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안된다.
- final클래스라면 Cloneable을 구현해도 위험이 크지 않지만, 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용 해야한다.